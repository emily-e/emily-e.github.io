<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Adventure Game Graphical Room Test</title>
	<script src="pixi.min.js"></script>
</head>
<body>
	<script src="game.js"></script>
	<script src="pathfind.js"></script>
	<script src="verbs.js"></script>
	<script src="rooms.js"></script>
	<script type="text/javascript">
'use strict';
/*
	https://www.pixijs.com/
		2d library for adventure game
		http://www.yeahbutisitflash.com/?p=5226&cpage=1
		https://medium.com/dailyjs/how-to-build-a-simple-sprite-animation-in-javascript-b764644244aa

		https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-and-animations-with-pixijs5

	https://www.redblobgames.com/pathfinding/a-star/introduction.html
	https://briangrinstead.com/blog/astar-search-algorithm-in-javascript/

	https://www.pixijs.com/tutorials
	http://pixijs.download/release/docs/index.html
	https://stackoverflow.com/questions/667045/getpixel-from-html-canvas

	https://pixijs.io/examples/?v=v5.2.1#/masks/filter.js
		https://www.html5gamedevs.com/topic/43900-masking-an-image-with-multiple-blurred-circles/
	https://stackoverflow.com/questions/40722796/is-it-possible-to-create-a-pixi-texture-from-multiple-image-sources-in-pixi-js

https://www.aseprite.org/docs/cli/#platform-specific-details
https://community.aseprite.org/t/is-there-a-way-to-export-layers-into-the-same-spritesheet-on-top-of-eachother/230
`aseprite -b bg-test.aseprite --save-as map-{layer}.png`

Export a room:
`aseprite -b --split-layers --all-layers room0.aseprite --sheet room0.png --data room0.json`
aseprite -b --split-layers --all-layers --filename-format "{title} (tag:{tag},frame:{frame},{layer})" room0.aseprite --sheet room0.png --data room0.json

Export icons
aseprite -b --filename-format "{title} (tag:{tag},frame:{frame},{layer})" icons.aseprite --sheet icons.png --data icons.json

{title} (tag:{tag},{layer},frame:{frame})

https://ihatetomatoes.net/how-to-work-with-images-and-pixi-js/

http://scottmcdonnell.github.io/pixi-examples/index.html?s=basics&f=text.js&title=Text
https://www.html5gamedevs.com/topic/9668-pixi-input-elements/
https://stackoverflow.com/questions/42111003/how-to-add-an-input-textbox-in-pixijs
https://pixijs.download/dev/docs/PIXI.Text.html
https://pixijs.io/pixi-text-style/#
https://stackoverflow.com/questions/46218500/pixijs-load-custom-font
https://www.html5gamedevs.com/topic/8659-about-fonts/
*/


const GameObjects = {
}

function GameObject(name) {
	this.name = name;
	this.spritesheet = name;
	GameObjects[name] = this;
	this.nextState = '';
	this.currentState = '';
	this.states = {};
	this.colorToMessage = ColorMessages;
	this.x = 0;
	this.y = 0;
	this.dx = 0;
	this.dy = 0;
	this.carryable = true;
	this.displayName = name;
	this.displayState = '';

	this.getDescription = function() {
		return ('longDescription' in this) ? this.longDescription : '';
	}

	this.isCarryable = function(status) {
		if(arguments.length > 0) { this.carryable = status; }
		return this.carryable;
	}
	this.as = function (description) {
		this.longDescription = description;
		return this;
	};
	this.aka = function (name) {
		this.displayName = name;
		return this;
	};
	this.setXY = function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	};
	this.setState = function (state) {
		this.nextState = state;
		return this;
	};

	this.setLocation = function (room) {
		this.currentRoom = room;
	};

	this.calculateState = function() { return this.nextState; }

	this.removeDisplay = function(container) {
		if(this.currentState in this.states) { 
			const state = this.states[this.currentState];
			Object.keys(state.layers)
				.forEach(z => {
					container.removeChild(state.layers[z]);
				});
			// container.removeChild(oldState.map.sprite);
		}
	};

	this.display = function (container, refresh) {
		let newState = this.calculateState();
		if(refresh || (newState != this.currentState)) {
			const newStateObj = this.states[newState];
			this.removeDisplay(container);
			Object.keys(newStateObj.layers)
				.forEach(z => {
//						console.log(z);
//						console.log(newStateObj);
						newStateObj.layers[z].x = this.x;
						newStateObj.layers[z].y = this.y;
						newStateObj.layers[z].zIndex = parseInt(this.y) + parseInt(z);
						newStateObj.layers[z].play();
						container.addChild(newStateObj.layers[z]);
				});
			this.currentState = newState;
		}

		const state = this.states[this.currentState];
		Object.keys(state.layers)
			.forEach(z => {
				state.layers[z].x = this.x;
				state.layers[z].y = this.y;
				state.layers[z].zIndex = parseInt(this.y) + parseInt(z);
		});
/*
		state.map.sprite.alpha = 0.5;
		state.map.sprite.x = this.x;
		state.map.sprite.y = this.y;
		state.map.sprite.zIndex = this.y + 1;
		container.addChild(state.map.sprite);*/
	};
}

function Player(name) {
	GameObject.call(this, name);
	this.inventory = new InventoryRoom(name + '.inventory');
	this.path = [];

	this.turn = function() {
		this.x += this.dx;
		this.y += this.dy;
		if(this.path.length > 1) {
			const pt = this.path.shift();
			this.dx = pt.x - this.x;
			this.dy = pt.y - this.y;
		} else if(this.path.length == 1) {
			this.path = [];
			this.dx = 0;
			this.dy = 0;
		}
	};

	this.isCarryable = function(status) { return false; }
	this.stop = function (sender) {
		console.log(this);
		this.path = [];
		this.dx = 0;
		this.dy = 0;
		return true;
	};
	this.wade = function (sender) {
		return false;
	};
	this.swim = function (sender) {
		return false;
	};
	this.goWest = function (sender) {
		console.log('west!');
		this.path = [];
		this.dx = 0;
		this.dy = 0;
		console.log(this.currentRoom.connections);
		if('west' in this.currentRoom.connections) {
			const newRoom = Rooms[this.currentRoom.connections.west];
			newRoom.moveTo(this, this.currentRoom, 'west', this.currentRoom.connections.west);
		}
		return true;
	};
	this.goNorth = function (sender) {
		console.log('north!');
		this.path = [];
		this.dx = 0;
		this.dy = 0;
		return true;
	};
	this.goEast =function (sender) {
		console.log('east!');
		this.path = [];
		this.dx = 0;
		this.dy = 0;
		console.log(this.currentRoom.connections);
		if('east' in this.currentRoom.connections) {
			const newRoom = Rooms[this.currentRoom.connections.east];
			newRoom.moveTo(this, this.currentRoom, 'east', this.currentRoom.connections.east);
		}
		return true;
	};
	this.goSouth = function (sender) {
		console.log('south!');
		this.path = [];
		this.dx = 0;
		this.dy = 0;
		return true;
	};

	this.fallState = false;
	this.fallCount = 0;
	this.fall = function (sender) {
		if(this.fallState) {
			this.fallState = true;
			this.fallCount = 0;
		} else if (this.fallcount > 44) {
			console.log('player fell too far.');
		} else {
			this.fallCount += 4;
		}
		this.dx = 0;
		this.dy = 4;
		return true;
	};

	this.calculateState = function() {
		if((this.dx == 0) && (this.dy == 0)) {
			return 'stand';
		} else {
			return 'walk';
		}
	};
}



const GameState = new GameData();

const Verbs = {};

const uiChrome = new UIChrome(Verbs);

/* Actual "game" description. */
const player = new Player('player').setXY(110, 316);
makeVerbs(player, Verbs);

new Room('room0')
	.as('A large field with a boulder, tree, and pond.')
	.with({ east: 'room1' })
	.having((new GameObject('chest'))
		.as('A large treasure chest')
		.setXY(590, 185)
		.setState('closed'))
	.having(player);
Rooms.room0.currentState = 'day';
new Room('room1')
	.as('The foothills of a mountain with a large sinkhole nearby.')
	.with({ west: 'room0' })
	.having((new GameObject('key')).setXY(77, 247));



/* Game start up code */
// The application will create a renderer using WebGL, if possible,
// with a fallback to a canvas render. It will also setup the ticker
// and the root stage PIXI.Container
const app = new PIXI.Application(); //{ resizeTo: window });

// The application will create a canvas element for you that you
// can then insert into the DOM
document.body.appendChild(app.view);

app.loader
	.add("player.json")
	.add("room0.json")
	.add("room1.json")
	.add("chest.json")
	.add("key.json")
	.add("icons.json")
	.load(
		(loader, resources) => {
			const screen = new PIXI.Container();
			const resizer = resize(app, screen);

			// Add event listener so that our resize function runs every time the
			// browser window is resized.
			window.addEventListener("resize", resizer);

			screen.sortableChildren = true;
			app.stage.addChild(uiChrome.icons);
			app.stage.addChild(screen);

			loadIconsFromSheet(uiChrome, 'icons', resources["icons.json"].spritesheet);
			uiChrome.display(screen);
			screen.y = uiChrome.height + 1;

			Object.keys(Rooms)
				.forEach(name => {
					if(!Rooms[name].loadAssets()) { return; }
					loadFromSheet(Rooms[name],
						Rooms[name].spritesheet,
						resources[Rooms[name].spritesheet + '.json'].spritesheet)
				});
			Object.keys(GameObjects)
				.forEach(name => {
					console.log(name);
					loadFromSheet(GameObjects[name],
						GameObjects[name].spritesheet,
						resources[GameObjects[name].spritesheet + '.json'].spritesheet)
					console.log(GameObjects[name]);
				});

			let currentRoom = player.currentRoom;
			currentRoom.setAnimation(screen);

			resizer();
			// Listen for frame updates
			app.ticker.add(() => {
				Object.keys(collide(player.states[player.currentState].map, player.x + player.dx, player.y + player.dy, currentRoom.colorToMessage,
						currentRoom.states[currentRoom.currentState].map))
					.forEach(rgb => currentRoom.colorToMessage[rgb](player));
				currentRoom.contains.forEach(obj => {
					if(obj == player) { return; }
					Object.keys(collide(player.states[player.currentState].map, player.x + player.dx - obj.x, player.y + player.dy - obj.y, 
							obj.colorToMessage, obj.states[obj.currentState].map))
						.forEach(rgb => obj.colorToMessage[rgb](player));
				});
				player.turn();

				if(currentRoom != player.currentRoom) {
					screen.removeChildren();
					player.currentRoom.setAnimation(screen);
					resizer();
				}
				currentRoom = player.currentRoom;
				currentRoom.updateAnimations(screen);
			});
		}
	);
</script>
</body>
</html>
