<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Adventure Game Graphical Room Test</title>
	<script src="pixi.min.js"></script>
</head>
<body>
	<script src="game.js"></script>
	<script type="text/javascript">
'use strict';
/*
	https://www.pixijs.com/
		2d library for adventure game
		http://www.yeahbutisitflash.com/?p=5226&cpage=1
		https://medium.com/dailyjs/how-to-build-a-simple-sprite-animation-in-javascript-b764644244aa

		https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-and-animations-with-pixijs5

	https://www.redblobgames.com/pathfinding/a-star/introduction.html
	https://briangrinstead.com/blog/astar-search-algorithm-in-javascript/

	https://www.pixijs.com/tutorials
	http://pixijs.download/release/docs/index.html
	https://stackoverflow.com/questions/667045/getpixel-from-html-canvas

	https://pixijs.io/examples/?v=v5.2.1#/masks/filter.js
		https://www.html5gamedevs.com/topic/43900-masking-an-image-with-multiple-blurred-circles/
	https://stackoverflow.com/questions/40722796/is-it-possible-to-create-a-pixi-texture-from-multiple-image-sources-in-pixi-js

https://www.aseprite.org/docs/cli/#platform-specific-details
https://community.aseprite.org/t/is-there-a-way-to-export-layers-into-the-same-spritesheet-on-top-of-eachother/230
`aseprite -b bg-test.aseprite --save-as map-{layer}.png`

Export a room:
`aseprite -b --split-layers --all-layers room0.aseprite --sheet room0.png --data room0.json`
aseprite -b --split-layers --all-layers --filename-format "{title} (tag:{tag},frame:{frame},{layer})" room0.aseprite --sheet room0.png --data room0.json

Export icons
aseprite -b --filename-format "{title} (tag:{tag},frame:{frame},{layer})" icons.aseprite --sheet icons.png --data icons.json

{title} (tag:{tag},{layer},frame:{frame})

https://ihatetomatoes.net/how-to-work-with-images-and-pixi-js/

*/

// http://scottmcdonnell.github.io/pixi-examples/index.html?s=demos&f=interactivity.js&title=Interactivity
function inputHandlers(player, screen) {
	function mvLeft() {
		console.log('left');
		player.dx = (player.dx < 0) ? 0 : -2;
		player.dy = 0;
	}
	function mvRight() {
		console.log('right');
		player.dx = (player.dx > 0) ? 0 : 2;
		player.dy = 0;
	}
	function mvUp() {
		console.log('up');
		player.dx = 0;
		player.dy = (player.dy < 0) ? 0 : -2;
	}
	function mvDown() {
		console.log('down');
		player.dx = 0;
		player.dy = (player.dy > 0) ? 0 : 2;
	}

	document.querySelector('body').addEventListener('keydown', function (evt) {
		// escape
		//if(evt.keyCode == 27) { eventHandler.mode(); }
		// left
		if(evt.keyCode == 37) { mvLeft(); }
		// up
		if(evt.keyCode == 38) { mvUp(); }
		// right
		if(evt.keyCode == 39) { mvRight(); }
		// down
		if(evt.keyCode == 40) { mvDown(); }
	});

	function no_op() {}

	screen.interactive = true;
	screen
		// set the mousedown and touchstart callback...
		.on('mousedown', no_op)
		.on('touchstart', no_op)

		// set the mouseup and touchend callback...
		.on('mouseup', no_op)
		.on('touchend', no_op)
		.on('mouseupoutside', no_op)
		.on('touchendoutside', no_op)

		// set the mouseover callback...
		.on('mouseover', no_op)

		// set the mouseout callback...
		.on('mouseout', no_op)
		// you can also listen to click and tap events :
		.on('click', event => {
			console.log('click');
			console.log(event);
			const p = event.data.getLocalPosition(screen);
			console.log(p);
		})
		.on('pointertap', event => {
		});
}

// The application will create a renderer using WebGL, if possible,
// with a fallback to a canvas render. It will also setup the ticker
// and the root stage PIXI.Container
const app = new PIXI.Application(); //{ resizeTo: window });

// The application will create a canvas element for you that you
// can then insert into the DOM
document.body.appendChild(app.view);


const ColorMessages = {
	'000000': function(p) {
		console.log('STOP');
		return p.stop(this);
	},
	'5fcde4': function(p) {
		return p.wade(this);
	},
	'5b6ee1': function(p) {
		return p.swim(this);
	},
	'76428a': function (p) {
		return p.fall(this);
	},
	'ff0001': function(p) {
		console.log('GO WEST');
		return p.goWest(this);
	},
	'ff0011': function(p) {
		return p.goNorth(this);
	},
	'ff0021': function(p) {
		console.log('GO EAST');
		return p.goEast(this);
	},
	'ff0031': function(p) {
		return p.goSouth(this);
	}
}


const Rooms = {
};

function Room(name) {
	this.name = name;
	this.spritesheet = name;
	Rooms[name] = this;
	this.currentState = '';
	this.states = {};
	this.colorToMessage = ColorMessages;
	this.connections = {};
	this.contains = [];
	this.setAnimation = function(container) {
		const state = this.states[this.currentState];
		console.log(this);
		Object.keys(state.layers)
			.forEach(z => {
				state.layers[z].play();
				container.addChild(state.layers[z]);
			});
		this.contains.forEach(obj => obj.display(container));
	};

	this.moveTo = function (obj, travelling, roomName) {
		const objMap = obj.maps[obj.currentMap];
		const roomMap = this.states[this.currentState].map;
		console.log(objMap);
		console.log(roomMap);
		const xCenter = Math.floor(objMap.width * objMap.x);
		const yCenter = Math.floor(objMap.height * objMap.y);
		if(travelling == 'east') {
			obj.x = (objMap.width - xCenter) + 2;
			obj.y = (roomMap.height  - 6) - (objMap.height - yCenter);
		} else if (travelling == 'west') {
			obj.x = (roomMap.width - 2) - (objMap.width - xCenter);
			obj.y = (roomMap.height  - 6) - (objMap.height - yCenter);
		}
		console.log(obj);
		console.log('new x y ' + obj.x + ', ' + obj.y);
		obj.currentRoom = this;
	};

	this.as = function (description) {
		this.longDescription = description;
		return this;
	};

	this.with = function (travel) {
		if('west' in travel) {
			this.connections.west = travel.west;
		} else if('east' in travel) {
			this.connections.east = travel.east;
		} else if('north' in travel) {
			this.connections.north = travel.north;
		} else if('south' in travel) {
			this.connections.south = travel.south;
		}
		return this;
	};

	this.having = function (gameObj) {
		gameObj.setLocation(this);
		this.contains.push(gameObj);
	};
}

const GameObjects = {
}

function GameObject(name) {
	this.name = name;
	this.spritesheet = name;
	GameObjects[name] = this;
	this.currentState = '';
	this.states = {};
	this.colorToMessage = ColorMessages;
	this.x = 0;
	this.y = 0;
	this.dx = 0;
	this.dy = 0;
	this.displayName = name;
	this.displayState = '';

	this.as = function (description) {
		this.longDescription = description;
		return this;
	};
	this.aka = function (name) {
		this.displayName = name;
		return this;
	};
	this.setXY = function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	};
	this.setState = function (state) {
		this.currentState = state;
		return this;
	};

	this.setLocation = function (room) {
		this.currentLocation = room;
	};

	this.display = function (container) {
		const state = this.states[this.currentState];
		console.log(this);
		Object.keys(state.layers)
			.forEach(z => {
				state.layers[z].x = this.x;
				state.layers[z].y = this.y;
				state.layers[z].zIndex = parseInt(this.y) + parseInt(z);
				state.layers[z].play();
				container.addChild(state.layers[z]);
			});
/*		state.map.sprite.x = this.x;
		state.map.sprite.y = this.y;
		state.map.sprite.zIndex = this.y + 1;
		container.addChild(state.map.sprite);*/
	};
}

new Room('room0')
	.as('A large field with a boulder, tree, and pond.')
	.with({ east: 'room1' })
	.having((new GameObject('chest')).setXY(590, 185).setState('closed'));
Rooms.room0.currentState = 'day';
new Room('room1')
	.as('The foothills of a mountain with a large sinkhole nearby.')
	.with({ west: 'room0' });


const player = {
	currentRoom: Rooms.room0,
	x: 110, y: 318,
	dx: 0, dy: 0,
	animState: '',
	currentMap: 'default',
	animations: {},
	maps: {},
	stop: function (sender) {
		console.log(this);
		this.dx = 0;
		this.dy = 0;
		return true;
	},
	wade: function (sender) {
		return false;
	},
	swim: function (sender) {
		return false;
	},
	goWest: function (sender) {
		console.log('west!');
		this.dx = 0;
		this.dy = 0;
		console.log(this.currentRoom.connections);
		if('west' in this.currentRoom.connections) {
			const newRoom = Rooms[this.currentRoom.connections.west];
			newRoom.moveTo(this, 'west', this.currentRoom.connections.west);
		}
		return true;
	},
	goNorth: function (sender) {
		console.log('north!');
		this.dx = 0;
		this.dy = 0;
		return true;
	},
	goEast: function (sender) {
		console.log('east!');
		this.dx = 0;
		this.dy = 0;
		console.log(this.currentRoom.connections);
		if('east' in this.currentRoom.connections) {
			const newRoom = Rooms[this.currentRoom.connections.east];
			newRoom.moveTo(this, 'east', this.currentRoom.connections.east);
		}
		return true;
	},
	goSouth: function (sender) {
		console.log('south!');
		this.dx = 0;
		this.dy = 0;
		return true;
	},
	fallState: false,
	fallCount: 0,
	fall: function (sender) {
		if(this.fallState) {
			this.fallState = true;
			this.fallCount = 0;
		} else if (this.fallcount > 44) {
			console.log('player fell too far.');
		} else {
			this.fallCount += 4;
		}
		this.dx = 0;
		this.dy = 4;
		return true;
	},

	setAnimation: function(container) {
		let newAnim = this.animState;
		if((this.dx == 0) && (this.dy == 0)) {
			newAnim = 'stand';
		} else {
			newAnim = 'walk';
		}
		if(newAnim != this.animState) {
			container.removeChild(this.animations[this.animState]);
			this.animState = newAnim;
			this.animations[this.animState].x = this.x;
			this.animations[this.animState].y = this.y;
			this.animations[this.animState].zIndex = this.y;
			this.animations[this.animState].play();
			container.addChild(this.animations[this.animState]);
/*
			this.maps.default.sprite.x = this.x;
			this.maps.default.sprite.y = this.y;
			this.maps.default.sprite.zIndex = this.y + 1;
			container.addChild(this.maps.default.sprite);*/
		}
	},

	updateAnimation: function() {
		this.animations[this.animState].x = this.x;
		this.animations[this.animState].y = this.y;
		this.animations[this.animState].zIndex = this.y;
/*
		this.maps.default.sprite.x = this.x;
		this.maps.default.sprite.y = this.y;
		this.maps.default.sprite.zIndex = this.y + 1;*/
	}
};


function collide(obj, ox, oy, dx, dy, room) {
	const roomMap = room.states[room.currentState].map;

	const objMap = obj.maps[obj.currentMap];

	const colors = {};
	const roomAnchorX = Math.floor(roomMap.width * roomMap.x);
	const roomAnchorY = Math.floor(roomMap.height * roomMap.y);
	for(let x = 0; x < objMap.width; x++) {
		const roomX = (ox + dx + x) - Math.floor(objMap.width * objMap.x) + roomAnchorX;
		if((roomX < 0) || (roomX >= roomMap.width)) { continue; }
		for(let y = 0; y < objMap.height; y++) {
			const roomY = (oy + dy + y) - Math.floor(objMap.height * objMap.y) + roomAnchorY;
			if((roomY < 0) || (roomY >= roomMap.height)) { continue; }
			const objOffset = (x + (y * objMap.width)) * 4;
			const roomOffset = (roomX + (roomY * roomMap.width)) * 4;

			// out of bounds on room
			if((roomOffset < 0) || (roomOffset > (roomMap.pixels.length - 4))) { continue; }
			// player map is transparent
			if(objMap.pixels[objOffset + 3] == 0) { continue; }
			// room map is transparent
			if(roomMap.pixels[roomOffset + 3] == 0) { continue; }

			const rgb = ((roomMap.pixels[roomOffset] < 16) ? '0' : '') + roomMap.pixels[roomOffset].toString(16)
				+ ((roomMap.pixels[roomOffset + 1] < 16) ? '0' : '') + roomMap.pixels[roomOffset + 1].toString(16)
				+ ((roomMap.pixels[roomOffset + 2] < 16) ? '0' : '') + roomMap.pixels[roomOffset + 2].toString(16);
			if(rgb in colors) { continue; }
			if(rgb in room.colorToMessage) {
				colors[rgb] = { roomX: roomX, roomY: roomY, objX: x, objY: y };
			}
		}
	}
	Object.keys(colors).forEach(rgb => room.colorToMessage[rgb](obj));
//	if((obj.dx != 0) || (obj.dy != 0)) { console.log('px,y ' + ox + ', ' + oy); }

	obj.updateAnimation();
}

const Verbs = {
};

function Verb(verb) {
	this.name = verb
	Verbs[verb] = this;
	this.available = true;
}


new Verb('look');
new Verb('walk');
new Verb('take');
new Verb('inventory');

const uiChrome = {
	icons: new PIXI.Container(),
	animations: {},
	verbs: {},
	verbList: [],
	width: 0,
	height: 0,
	addVerb: function (verb) {
		if(!(verb in this.verbs)) {
			this.verbList.push(verb);
			if(verb in Verbs) { this.verbs[verb] = Verbs[verb]; }
		}
	},
	display: function () {
		this.icons.interactive = true;
		let currentVerb = '';
		let currentGraphics = {};
		this.verbList.forEach(verb => {
			if(!Verbs[verb].available) { return; }
			const anim = this.animations[verb];
			anim.interactive = true;
			this.icons.addChild(anim);
			anim.play();
			anim.x = this.width + 1;
			this.width = anim.x + anim.width;
			this.height = Math.max(this.height, anim.height);
			console.log(verb + ', anim extents: ' + anim.width + ', ' + anim.height);
			anim.on('click', evt => {
				if(verb != currentVerb) {
					if(currentVerb != '') {
						this.icons.removeChild(currentGraphics);
					}
					const graphics = new PIXI.Graphics();
					graphics.beginFill(0xfbf236, 0.5);
					graphics.lineStyle(1, 0xfbf236, 0.8);
					graphics.drawRect(0, 0, anim.width, anim.height);
					graphics.x = anim.x;
					this.icons.addChild(graphics);
					currentVerb = verb;
					currentGraphics = graphics;
				} else {
					if(currentVerb != '') {
						this.icons.removeChild(currentGraphics);
						currentVerb = '';
					}
				}
				console.log(verb); 
			});
		});
	}
};

const screen = new PIXI.Container();
//https://medium.com/@michelfariarj/scale-a-pixi-js-game-to-fit-the-screen-1a32f8730e9c
// Consider that WIDTH and HEIGHT are defined as the width and height of your unresized game in pixels.
function resize () {
	const WIDTH = screen.width + screen.x;
	const HEIGHT = screen.height + screen.y;

		const vpw = window.innerWidth - 16;  // Width of the viewport
		const vph = window.innerHeight - 16; // Height of the viewport
		let nvw; // New game width
		let nvh; // New game height

		// The aspect ratio is the ratio of the screen's sizes in different dimensions.
		// The height-to-width aspect ratio of the game is HEIGHT / WIDTH.
		
		if (vph / vpw < HEIGHT / WIDTH) {
			// If height-to-width ratio of the viewport is less than the height-to-width ratio
			// of the game, then the height will be equal to the height of the viewport, and
			// the width will be scaled.
			nvh = vph;
			nvw = (nvh * WIDTH) / HEIGHT;
		} else {
			// In the else case, the opposite is happening.
			nvw = vpw;
			nvh = (nvw * HEIGHT) / WIDTH;
		}
    
		// Set the game screen size to the new values.
		// This command only makes the screen bigger --- it does not scale the contents of the game.
		// There will be a lot of extra room --- or missing room --- if we don't scale the stage.
		app.renderer.resize(nvw, nvh);
    
		// This command scales the stage to fit the new size of the game.
		app.stage.scale.set(nvw / WIDTH, nvh / HEIGHT);
}

// Add event listener so that our resize function runs every time the
// browser window is resized.
window.addEventListener("resize", resize);

app.loader
	.add("sprite-test-v2.json")
	.add("room0.json")
	.add("room1.json")
	.add("chest.json")
	.add("icons.json")
	.load(
		(loader, resources) => {
			screen.sortableChildren = true;
			app.stage.addChild(uiChrome.icons);
			app.stage.addChild(screen);

			loadIconsFromSheet(uiChrome, 'icons', resources["icons.json"].spritesheet);
			uiChrome.display();
			screen.y = uiChrome.height + 1;

			Object.keys(Rooms)
				.forEach(name => {
					loadFromSheet(Rooms[name],
						Rooms[name].spritesheet,
						resources[Rooms[name].spritesheet + '.json'].spritesheet)
				});
			Object.keys(GameObjects)
				.forEach(name => {
					console.log(name);
					loadFromSheet(GameObjects[name],
						GameObjects[name].spritesheet,
						resources[GameObjects[name].spritesheet + '.json'].spritesheet)
					console.log(GameObject[name]);
				});

			loadSpriteFromSheet(player, 'sprite-test-v2', resources["sprite-test-v2.json"].spritesheet);


			player.currentRoom = Rooms.room0;
			let currentRoom = player.currentRoom;
			currentRoom.setAnimation(screen);
			console.log('here1');
			player.setAnimation(screen);
			console.log('here2');
			inputHandlers(player, screen);


			resize();
			// Listen for frame updates
			app.ticker.add(() => {
				collide(player, player.x, player.y, player.dx, player.dy, currentRoom);
				currentRoom.contains.forEach(gameObj => {
					collide(player, player.x - gameObj.x, player.y - gameObj.y, 
						player.dx, player.dy, gameObj);
				});
				player.x += player.dx;
				player.y += player.dy;

				if(currentRoom != player.currentRoom) {
					screen.removeChildren();
					player.currentRoom.setAnimation(screen);
					resize();
				}
				currentRoom = player.currentRoom;
				player.setAnimation(screen);
			});
		}
	);



/*
Pathfinding:
	Avatar
		Bound box
		Movement center
	Map
		2D grid with bounds
		Sprites with bounds
	Goal (x,y)
*/

</script>
</body>
</html>
