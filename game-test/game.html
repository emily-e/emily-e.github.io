<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Adventure Game Graphical Room Test</title>
	<script src="pixi.min.js"></script>
</head>
<body>
	<script type="text/javascript">
'use strict';
/*
	https://www.pixijs.com/
		2d library for adventure game
		http://www.yeahbutisitflash.com/?p=5226&cpage=1
		https://medium.com/dailyjs/how-to-build-a-simple-sprite-animation-in-javascript-b764644244aa

		https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-and-animations-with-pixijs5

	https://www.redblobgames.com/pathfinding/a-star/introduction.html
	https://briangrinstead.com/blog/astar-search-algorithm-in-javascript/

	https://www.pixijs.com/tutorials
	http://pixijs.download/release/docs/index.html
	https://stackoverflow.com/questions/667045/getpixel-from-html-canvas

	https://pixijs.io/examples/?v=v5.2.1#/masks/filter.js
		https://www.html5gamedevs.com/topic/43900-masking-an-image-with-multiple-blurred-circles/
	https://stackoverflow.com/questions/40722796/is-it-possible-to-create-a-pixi-texture-from-multiple-image-sources-in-pixi-js

https://www.aseprite.org/docs/cli/#platform-specific-details
https://community.aseprite.org/t/is-there-a-way-to-export-layers-into-the-same-spritesheet-on-top-of-eachother/230
`aseprite -b bg-test.aseprite --save-as map-{layer}.png`

Export a room:
`aseprite -b --split-layers --all-layers room0.aseprite --sheet room0.png --data room0.json`
aseprite -b --split-layers --all-layers --filename-format "{title} (tag:{tag},frame:{frame},{layer})" room0.aseprite --sheet room0.png --data room0.json

Export icons
aseprite -b --filename-format "{title} (tag:{tag},frame:{frame},{layer})" icons.aseprite --sheet icons.png --data icons.json

{title} (tag:{tag},{layer},frame:{frame})

https://ihatetomatoes.net/how-to-work-with-images-and-pixi-js/

*/

// http://scottmcdonnell.github.io/pixi-examples/index.html?s=demos&f=interactivity.js&title=Interactivity
function inputHandlers(player, screen) {
	function mvLeft() {
		console.log('left');
		player.dx = (player.dx < 0) ? 0 : -2;
		player.dy = 0;
	}
	function mvRight() {
		console.log('right');
		player.dx = (player.dx > 0) ? 0 : 2;
		player.dy = 0;
	}
	function mvUp() {
		console.log('up');
		player.dx = 0;
		player.dy = (player.dy < 0) ? 0 : -2;
	}
	function mvDown() {
		console.log('down');
		player.dx = 0;
		player.dy = (player.dy > 0) ? 0 : 2;
	}

	document.querySelector('body').addEventListener('keydown', function (evt) {
		// escape
		//if(evt.keyCode == 27) { eventHandler.mode(); }
		// left
		if(evt.keyCode == 37) { mvLeft(); }
		// up
		if(evt.keyCode == 38) { mvUp(); }
		// right
		if(evt.keyCode == 39) { mvRight(); }
		// down
		if(evt.keyCode == 40) { mvDown(); }
	});

	function no_op() {}

	screen.interactive = true;
	screen
		// set the mousedown and touchstart callback...
		.on('mousedown', no_op)
		.on('touchstart', no_op)

		// set the mouseup and touchend callback...
		.on('mouseup', no_op)
		.on('touchend', no_op)
		.on('mouseupoutside', no_op)
		.on('touchendoutside', no_op)

		// set the mouseover callback...
		.on('mouseover', no_op)

		// set the mouseout callback...
		.on('mouseout', no_op)
		// you can also listen to click and tap events :
		.on('click', event => {
			console.log('click');
			console.log(event);
			const p = event.data.getLocalPosition(screen);
			console.log(p);
		})
		.on('pointertap', event => {
		});
}

// The application will create a renderer using WebGL, if possible,
// with a fallback to a canvas render. It will also setup the ticker
// and the root stage PIXI.Container
const app = new PIXI.Application(); //{ resizeTo: window });

// The application will create a canvas element for you that you
// can then insert into the DOM
document.body.appendChild(app.view);

const ColorMessages = {
	'000000': function(p) {
		console.log('STOP');
		return p.stop(this);
	},
	'5fcde4': function(p) {
		return p.wade(this);
	},
	'5b6ee1': function(p) {
		return p.swim(this);
	},
	'76428a': function (p) {
		return p.fall(this);
	},
	'ff0001': function(p) {
		console.log('GO WEST');
		return p.goWest(this);
	},
	'ff0011': function(p) {
		return p.goNorth(this);
	},
	'ff0021': function(p) {
		console.log('GO EAST');
		return p.goEast(this);
	},
	'ff0031': function(p) {
		return p.goSouth(this);
	}
}
/*
class Room {

}
*/

function parseFrameName(name) {
	const info = {};
	name.substring(name.indexOf('(') + 1, name.lastIndexOf(')'))
		.split(',')
		.forEach(kv => {
			const pair = kv.split(':');
			info[pair[0]] = pair[1];
		});
	return info;
}

function getPixels(sprite) {
	const canvas = document.createElement('canvas');
	console.log('Char Map: width - ' + sprite.width + ' height - ' + sprite.height);
	canvas.width = sprite.width;
	canvas.height = sprite.height;
	console.log('txt ' + sprite.texture.orig.x + ' ' + sprite.texture.orig.y);

	const ctx = canvas.getContext('2d');
	ctx.drawImage(sprite.texture.baseTexture.resource.source,
		sprite.texture.orig.x, sprite.texture.orig.y,
		sprite.texture.orig.width, sprite.texture.orig.height,
		0,0,
		sprite.width, sprite.height);

	return ctx.getImageData(0, 0, sprite.width, sprite.height).data;
}

const Rooms = {
};

function Room(name) {
	this.name = name;
	this.spritesheet = name;
	Rooms[name] = this;
	this.roomState = '';
	this.states = {};
	this.colorToMessage = ColorMessages;
	this.connections = {};
	this.contains = [];
	this.setAnimation = function(container) {
		const state = this.states[this.roomState];
		console.log(this);
		Object.keys(state.layers)
			.forEach(z => {
				state.layers[z].play();
				container.addChild(state.layers[z]);
			});
		this.contains.forEach(obj => obj.display(container));
	};

	this.moveTo = function (obj, travelling, roomName) {
		const objMap = obj.maps[obj.currentMap];
		const roomMap = this.states[this.roomState].map;
		console.log(objMap);
		console.log(roomMap);
		const xCenter = Math.floor(objMap.width * objMap.x);
		const yCenter = Math.floor(objMap.height * objMap.y);
		if(travelling == 'east') {
			obj.x = (objMap.width - xCenter) + 2;
			obj.y = (roomMap.height  - 6) - (objMap.height - yCenter);
		} else if (travelling == 'west') {
			obj.x = (roomMap.width - 2) - (objMap.width - xCenter);
			obj.y = (roomMap.height  - 6) - (objMap.height - yCenter);
		}
		console.log(obj);
		console.log('new x y ' + obj.x + ', ' + obj.y);
		obj.currentRoom = this;
	};

	this.as = function (description) {
		this.longDescription = description;
		return this;
	};

	this.with = function (travel) {
		if('west' in travel) {
			this.connections.west = travel.west;
		} else if('east' in travel) {
			this.connections.east = travel.east;
		} else if('north' in travel) {
			this.connections.north = travel.north;
		} else if('south' in travel) {
			this.connections.south = travel.south;
		}
		return this;
	};

	this.having = function (gameObj) {
		gameObj.placeInto(this);
		this.contains.push(gameObj);
	};
}

new Room('room0')
	.as('A large field with a boulder, tree, and pond.')
	.with({ east: 'room1' });
Rooms.room0.roomState = 'day';
new Room('room1')
	.as('The foothills of a mountain with a large sinkhole nearby.')
	.with({ west: 'room0' });


function loadRoomFromSheet(room, roomName, spritesheet) {
	const animations = {};
	Object.keys(spritesheet.textures)
		.forEach(name => {
			if(name.indexOf(roomName + ' (') != 0) { return; }
			const info = parseFrameName(name);
			console.log(info);
			if(!('tag' in info)) { info.tag = 'default'; }
			if(!(info.tag in room.states)) {
				room.states[info.tag] = {
					layers: {},
					map: {}
				};
			}
			const tag = room.states[info.tag];

			// https://www.html5gamedevs.com/topic/18018-how-to-read-pixel-color/
			// https://pixijs.io/examples/?v=v5.0.0-rc.2#/textures/gradient-resource.js
			if('map' in info) {
				const map = new PIXI.Sprite(spritesheet.textures[name]);
				tag.map = {
					pixels: getPixels(map),
					width: map.width, height: map.height
				};
			} else if('z' in info) {
				if (!(info.tag in animations)) { animations[info.tag] = {}; }
				const animTag = animations[info.tag];
				if(!(info.z in animTag)) { animTag[info.z] = []; }
				animTag[info.z].push(spritesheet.textures[name]);
			}
		});
	console.log(animations);
	Object.keys(animations)
		.forEach(tag => {
			console.log(tag);
			Object.keys(animations[tag])
				.forEach(z => {
					room.states[tag].layers[z] = new PIXI.AnimatedSprite(animations[tag][z]);
					room.states[tag].layers[z].zIndex = Number.parseInt(z);
					room.states[tag].layers[z].animationSpeed = 0.167; 
				});
		});
}

const player = {
	currentRoom: Rooms.room0,
	x: 110, y: 318,
	dx: 0, dy: 0,
	animState: '',
	currentMap: 'default',
	animations: {},
	maps: {},
	stop: function (sender) {
		console.log(this);
		this.dx = 0;
		this.dy = 0;
		return true;
	},
	wade: function (sender) {
		return false;
	},
	swim: function (sender) {
		return false;
	},
	goWest: function (sender) {
		console.log('west!');
		this.dx = 0;
		this.dy = 0;
		console.log(this.currentRoom.connections);
		if('west' in this.currentRoom.connections) {
			const newRoom = Rooms[this.currentRoom.connections.west];
			newRoom.moveTo(this, 'west', this.currentRoom.connections.west);
		}
		return true;
	},
	goNorth: function (sender) {
		console.log('north!');
		this.dx = 0;
		this.dy = 0;
		return true;
	},
	goEast: function (sender) {
		console.log('east!');
		this.dx = 0;
		this.dy = 0;
		console.log(this.currentRoom.connections);
		if('east' in this.currentRoom.connections) {
			const newRoom = Rooms[this.currentRoom.connections.east];
			newRoom.moveTo(this, 'east', this.currentRoom.connections.east);
		}
		return true;
	},
	goSouth: function (sender) {
		console.log('south!');
		this.dx = 0;
		this.dy = 0;
		return true;
	},
	fallState: false,
	fallCount: 0,
	fall: function (sender) {
		if(this.fallState) {
			this.fallState = true;
			this.fallCount = 0;
		} else if (this.fallcount > 44) {
			console.log('player fell too far.');
		} else {
			this.fallCount += 4;
		}
		this.dx = 0;
		this.dy = 4;
		return true;
	},

	setAnimation: function(container) {
		let newAnim = this.animState;
		if((this.dx == 0) && (this.dy == 0)) {
			newAnim = 'stand';
		} else {
			newAnim = 'walk';
		}
		if(newAnim != this.animState) {
			container.removeChild(this.animations[this.animState]);
			this.animState = newAnim;
			this.animations[this.animState].x = this.x;
			this.animations[this.animState].y = this.y;
			this.animations[this.animState].zIndex = this.y;
			this.animations[this.animState].play();
			container.addChild(this.animations[this.animState]);
		}
	},

	updateAnimation: function() {
		this.animations[this.animState].x = this.x;
		this.animations[this.animState].y = this.y;
		this.animations[this.animState].zIndex = this.y;
	}
};

function collectAnimations(animations, obj) {
	console.log(animations);
	Object.keys(animations)
		.forEach(name => {
			console.log(animations[name]);
			obj.animations[name] = new PIXI.AnimatedSprite(animations[name]);
			obj.animations[name].animationSpeed = 0.167; 
		});
	console.log(obj.animations);
}

function loadSpriteFromSheet(obj, spriteName, spritesheet) {
	const animations = {};
	Object.keys(spritesheet.textures)
		.forEach(name => {
			if(name.indexOf(spriteName + ' (') != 0) { return; }
			const info = parseFrameName(name);
			if('tag' in info) {
				if(info.tag == 'map') {
					const map = new PIXI.Sprite(spritesheet.textures[name]);
					const mapName = ('map' in info) ? info.map : 'default';
					obj.maps[mapName] = {
						pixels: getPixels(map),
						x: map.anchor.x, y: map.anchor.y,
						width: map.width, height: map.height
					};
					console.log(obj.maps[mapName].pixels);
					console.log(map.anchor);
				} else {
					if (!(info.tag in animations)) {
						animations[info.tag] = [];
					}
					animations[info.tag].push(spritesheet.textures[name]);
				}
			}
			console.log(info);
		});
	collectAnimations(animations, obj);
}

function moveAndCollide(obj, room) {
	const roomMap = room.states[room.roomState].map;

	const objMap = obj.maps[obj.currentMap];

	let flag = false;
	for(let x = 0; x < objMap.width; x++) {
		if(flag) { break; }
		const roomX = (obj.x + obj.dx + x) - Math.floor(objMap.width * objMap.x);
		if((roomX < 0) || (roomX >= roomMap.width)) { continue; }
		for(let y = 0; y < objMap.height; y++) {
			const roomY = (obj.y + obj.dy + y) - Math.floor(objMap.height * objMap.y);
			if((roomY < 0) || (roomY >= roomMap.height)) { continue; }
			const objOffset = (x + (y * objMap.width)) * 4;
			const roomOffset = (roomX + (roomY * roomMap.width)) * 4;

			// out of bounds on room
			if((roomOffset < 0) || (roomOffset > (roomMap.pixels.length - 4))) { continue; }
			// player map is transparent
			if(objMap.pixels[objOffset + 3] == 0) { continue; }
			//console.log('poffs ' + playerOffset + ' xy ' + x + ', ' + y + 'alpha ' + player.pixels[playerOffset + 3] + 'r ' + player.pixels[playerOffset]);
			// room map is transparent
			if(roomMap.pixels[roomOffset + 3] == 0) { continue; }

			const rgb = ((roomMap.pixels[roomOffset] < 16) ? '0' : '') + roomMap.pixels[roomOffset].toString(16)
				+ ((roomMap.pixels[roomOffset + 1] < 16) ? '0' : '') + roomMap.pixels[roomOffset + 1].toString(16)
				+ ((roomMap.pixels[roomOffset + 2] < 16) ? '0' : '') + roomMap.pixels[roomOffset + 2].toString(16);
			if(rgb in room.colorToMessage) {
//				console.log(rgb);
//				console.log('rx,y ' + roomX + ', ' + roomY);
				flag = room.colorToMessage[rgb](obj);
			}
			if(flag) { break; }
		}
	}
	obj.x += obj.dx;
	obj.y += obj.dy;
	if((obj.dx != 0) || (obj.dy != 0)) { console.log('px,y ' + obj.x + ', ' + obj.y); }

	obj.updateAnimation();
}

const Verbs = {
};

function Verb(verb) {
	this.name = verb
	Verbs[verb] = this;
	this.available = true;
}


new Verb('look');
new Verb('walk');
new Verb('take');
new Verb('inventory');

const uiChrome = {
	icons: new PIXI.Container(),
	animations: {},
	verbs: {},
	verbList: [],
	width: 0,
	height: 0,
	addVerb: function (verb) {
		if(!(verb in this.verbs)) {
			this.verbList.push(verb);
			if(verb in Verbs) { this.verbs[verb] = Verbs[verb]; }
		}
	},
	display: function () {
		this.icons.interactive = true;
		this.verbList.forEach(verb => {
			if(!Verbs[verb].available) { return; }
			const anim = this.animations[verb];
			anim.interactive = true;
			this.icons.addChild(anim);
			anim.play();
			anim.x = this.width + 1;
			this.width = anim.x + anim.width;
			this.height = Math.max(this.height, anim.height);
			console.log(verb + ', anim extents: ' + anim.width + ', ' + anim.height);
			anim.on('click', evt => { console.log(verb); });
		});
	}
};

function loadIconsFromSheet(obj, iconsName, spritesheet) {
	const animations = {};
	Object.keys(spritesheet.textures)
		.forEach(name => {
			if(name.indexOf(iconsName + ' (') != 0) { return; }
			const info = parseFrameName(name);
			if('tag' in info) {
				obj.addVerb(info.tag);
				if (!(info.tag in animations)) {
					animations[info.tag] = [];
				}
				animations[info.tag].push(spritesheet.textures[name]);
			}
		});
	collectAnimations(animations, obj);
}

const screen = new PIXI.Container();
//https://medium.com/@michelfariarj/scale-a-pixi-js-game-to-fit-the-screen-1a32f8730e9c
// Consider that WIDTH and HEIGHT are defined as the width and height of your unresized game in pixels.
function resize () {
	const WIDTH = screen.width + screen.x;
	const HEIGHT = screen.height + screen.y;

		const vpw = window.innerWidth - 16;  // Width of the viewport
		const vph = window.innerHeight - 16; // Height of the viewport
		let nvw; // New game width
		let nvh; // New game height

		// The aspect ratio is the ratio of the screen's sizes in different dimensions.
		// The height-to-width aspect ratio of the game is HEIGHT / WIDTH.
		
		if (vph / vpw < HEIGHT / WIDTH) {
			// If height-to-width ratio of the viewport is less than the height-to-width ratio
			// of the game, then the height will be equal to the height of the viewport, and
			// the width will be scaled.
			nvh = vph;
			nvw = (nvh * WIDTH) / HEIGHT;
		} else {
			// In the else case, the opposite is happening.
			nvw = vpw;
			nvh = (nvw * HEIGHT) / WIDTH;
		}
    
		// Set the game screen size to the new values.
		// This command only makes the screen bigger --- it does not scale the contents of the game.
		// There will be a lot of extra room --- or missing room --- if we don't scale the stage.
		app.renderer.resize(nvw, nvh);
    
		// This command scales the stage to fit the new size of the game.
		app.stage.scale.set(nvw / WIDTH, nvh / HEIGHT);
}

// Add event listener so that our resize function runs every time the
// browser window is resized.
window.addEventListener("resize", resize);

app.loader
	.add("sprite-test-v2.json")
	.add("room0.json")
	.add("room1.json")
	.add("icons.json")
	.load(
		(loader, resources) => {
			screen.sortableChildren = true;
			app.stage.addChild(uiChrome.icons);
			app.stage.addChild(screen);

			loadIconsFromSheet(uiChrome, 'icons', resources["icons.json"].spritesheet);
			uiChrome.display();
			screen.y = uiChrome.height + 1;

			Object.keys(Rooms)
				.forEach(name => {
					loadRoomFromSheet(Rooms[name],
						Rooms[name].spritesheet,
						resources[Rooms[name].spritesheet + '.json'].spritesheet)
				});

			loadSpriteFromSheet(player, 'sprite-test-v2', resources["sprite-test-v2.json"].spritesheet);


			player.currentRoom = Rooms.room0;
			let currentRoom = player.currentRoom;
			currentRoom.setAnimation(screen);
			console.log('here1');
			player.setAnimation(screen);
			console.log('here2');
			inputHandlers(player, screen);


			resize();
			// Listen for frame updates
			app.ticker.add(() => {
				moveAndCollide(player, currentRoom);
				if(currentRoom != player.currentRoom) {
					screen.removeChildren();
					player.currentRoom.setAnimation(screen);
					resize();
				}
				currentRoom = player.currentRoom;
				player.setAnimation(screen);
			});
		}
	);



/*
Pathfinding:
	Avatar
		Bound box
		Movement center
	Map
		2D grid with bounds
		Sprites with bounds
	Goal (x,y)
*/

</script>
</body>
</html>
