<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Adventure Game Graphical Room Test</title>
	<script src="pixi.min.js"></script>
</head>
<body>
	<script type="text/javascript">
/*
	https://www.pixijs.com/
		2d library for adventure game
		http://www.yeahbutisitflash.com/?p=5226&cpage=1
		https://medium.com/dailyjs/how-to-build-a-simple-sprite-animation-in-javascript-b764644244aa

		https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-and-animations-with-pixijs5

	https://www.redblobgames.com/pathfinding/a-star/introduction.html
	https://briangrinstead.com/blog/astar-search-algorithm-in-javascript/

	https://www.pixijs.com/tutorials
	http://pixijs.download/release/docs/index.html
	https://stackoverflow.com/questions/667045/getpixel-from-html-canvas

	https://pixijs.io/examples/?v=v5.2.1#/masks/filter.js
		https://www.html5gamedevs.com/topic/43900-masking-an-image-with-multiple-blurred-circles/
	https://stackoverflow.com/questions/40722796/is-it-possible-to-create-a-pixi-texture-from-multiple-image-sources-in-pixi-js

https://www.aseprite.org/docs/cli/#platform-specific-details
https://community.aseprite.org/t/is-there-a-way-to-export-layers-into-the-same-spritesheet-on-top-of-eachother/230
`aseprite -b bg-test.aseprite --save-as map-{layer}.png`

Export a room:
`aseprite -b --split-layers --all-layers room0.aseprite --sheet room0.png --data room0.json`

https://ihatetomatoes.net/how-to-work-with-images-and-pixi-js/

*/
// The application will create a renderer using WebGL, if possible,
// with a fallback to a canvas render. It will also setup the ticker
// and the root stage PIXI.Container
const app = new PIXI.Application();

// The application will create a canvas element for you that you
// can then insert into the DOM
document.body.appendChild(app.view);

//PIXI.Sprite.fromImage();
// load the texture we need
app.loader
	.add("spritesheet.json")
	.add("sprite-test-v2.json")
	.add("room0.json")
//	.add('room_z0', 'room_0-z_0.png')
//	.add('room_z15', 'room_0-z_15.png')
	.load(
		(loader, resources) => {
			const room = new PIXI.Container();
			room.sortableChildren = true;
			app.stage.addChild(room);

			const roomSheet = resources["room0.json"].spritesheet;
			console.log(roomSheet);
			const roomMap = {
				pixels: [], width: 0, height: 0
			};

			Object.keys(roomSheet.textures)
				.forEach(name => {
					const info = {};
					name.substring(name.indexOf('(') + 1, name.lastIndexOf(')'))
						.split(',')
						.forEach(kv => {
							const pair = kv.split(':');
							info[pair[0]] = pair[1];
						});
					console.log(info);
					if('z' in info) {
						const layer = new PIXI.Sprite(roomSheet.textures[name]);
						layer.zIndex = info.z;
						room.addChild(layer);
					}
					// https://www.html5gamedevs.com/topic/18018-how-to-read-pixel-color/
					// https://pixijs.io/examples/?v=v5.0.0-rc.2#/textures/gradient-resource.js
					if('map' in info) {
						const map = new PIXI.Sprite(roomSheet.textures[name]);
						console.log('Map: width - ' + map.width + ' height - ' + map.height);
						const canvas = document.createElement('canvas');
						canvas.width = map.width;
						canvas.height = map.height;
						const ctx = canvas.getContext('2d');
						ctx.drawImage(map.texture.baseTexture.resource.source,
							map.texture.orig.x, map.texture.orig.y,
							map.texture.orig.width, map.texture.orig.height,
							0,0,
							map.width, map.height);
						roomMap.pixels = ctx.getImageData(0, 0, map.width, map.height).data
						roomMap.width = map.width;
						roomMap.height = map.height;
						//console.log(roomMap.pixels);
					}
				});

			room.interactive = true;
		/*
room
        // set the mousedown and touchstart callback...
        .on('mousedown', onButtonDown)
        .on('touchstart', onButtonDown)

        // set the mouseup and touchend callback...
        .on('mouseup', onButtonUp)
        .on('touchend', onButtonUp)
        .on('mouseupoutside', onButtonUp)
        .on('touchendoutside', onButtonUp)

        // set the mouseover callback...
        .on('mouseover', onButtonOver)

        // set the mouseout callback...
        .on('mouseout', onButtonOut)


        // you can also listen to click and tap events :
        //.on('click', noop)
*/
			//    bunny.x = app.renderer.width / 2;
			//    bunny.y = app.renderer.height / 2;
			// Rotate around the center
			//    bunny.anchor.x = 0.5;
			//    bunny.anchor.y = 0.5;

			//    app.stage.addChild(bunny);

			const playerCanvas = document.createElement('canvas');
			const playerCtx = playerCanvas.getContext('2d');
			const player = {
				x: 110, y: 318,
				dx: 0, dy: 0,
				pixels: {},
				anchor: { x: 0, y: 0, width: 0, height: 0 }
			}

			const sheet2 = resources["sprite-test-v2.json"].spritesheet;
			console.log(sheet2);
			const animations = {};
			Object.keys(sheet2.textures)
				.forEach(name => {
					const info = {};
					name.substring(name.indexOf('(') + 1, name.lastIndexOf(')'))
						.split(',')
						.forEach(kv => {
							const pair = kv.split(':');
							info[pair[0]] = pair[1];
						});
					if('tag' in info) {
						if(info.tag == 'map') {
							const map = new PIXI.Sprite(sheet2.textures[name]);
							console.log('Char Map: width - ' + map.width + ' height - ' + map.height);
							playerCanvas.width = map.width;
							playerCanvas.height = map.height;
							console.log('txt ' + map.texture.orig.x + ' ' + map.texture.orig.y);
							playerCtx.drawImage(map.texture.baseTexture.resource.source,
								map.texture.orig.x, map.texture.orig.y,
								map.texture.orig.width, map.texture.orig.height,
								0,0,
								map.width, map.height);
							player.pixels = playerCtx.getImageData(0, 0, map.width, map.height).data;
							console.log(player.pixels);
							console.log(map.anchor);
							player.anchor.x = map.anchor.x;
							player.anchor.y = map.anchor.y;
							player.anchor.width = map.width;
							player.anchor.height = map.height;
						}// else {
							if (!(info.tag in animations)) {
								animations[info.tag] = [];
							}
							const frames = animations[info.tag];
							frames.push(sheet2.textures[name]);
						//}
					}
					console.log(info);
				});
			console.log(animations);
			const anims = {};
			Object.keys(animations)
				.forEach(name => {
					console.log(animations[name]);
					anims[name] = new PIXI.AnimatedSprite(animations[name]);
				});
			console.log(anims);

			const sheet = resources["spritesheet.json"].spritesheet;
			//const textures = new PIXI.Sprite(sheet.textures["sprite-test.png"]);

			//const anim = new PIXI.AnimatedSprite(sheet.animations['test']);
			let anim = anims.stand;
			//anim.updateAnchor = true;  

			anim.x = player.x;
			anim.y = player.y;
			anim.zIndex = player.y;

			function mvLeft() {
				console.log('left');
				player.dy = 0;
				if (player.dx < 0) {
					player.dx = 0;
				} else {
					player.dx = -2;
				}
			}
			function mvRight() {
				console.log('right');
				player.dy = 0;
				if (player.dx > 0) {
					player.dx = 0;
				} else {
					player.dx = 2;
				}
			}
			function mvUp() {
				console.log('up');
				player.dx = 0;
				if (player.dy < 0) {
					player.dy = 0;
				} else {
					player.dy = -2;
				}
			}
			function mvDown() {
				console.log('down');
				player.dx = 0;
				if (player.dy > 0) {
					player.dy = 0;
				} else {
					player.dy = 2;
				}
			}

			document.querySelector('body').addEventListener('keydown', function (evt) {
				// escape
				//if(evt.keyCode == 27) { eventHandler.mode(); }
				// left
				if(evt.keyCode == 37) { mvLeft(); }
				// up
				if(evt.keyCode == 38) { mvUp(); }
				// right
				if(evt.keyCode == 39) { mvRight(); }
				// down
				if(evt.keyCode == 40) { mvDown(); }
			});

			anim.animationSpeed = 0.167; 
			anim.play();
			room.addChild(anim);

			console.log(room);

			console.log(roomMap.pixels);

			const mapAnim = anims.map;
			room.addChild(mapAnim);
			mapAnim.x = player.x;
			mapAnim.y = player.y;
			mapAnim.zIndex = player.y + 1;

			// Listen for frame updates
			app.ticker.add(() => {
				let newAnim = anim;
				if((player.dx == 0) && (player.dy == 0)) {
					newAnim = anims.stand;
				} else {
					newAnim = anims.walk;
				}
				if(newAnim != anim) {
					room.removeChild(anim);
					anim = newAnim;
					anim.animationSpeed = 0.167; 
					anim.play();
					room.addChild(anim);
				}

				let flag = false;
				for(let x = 0; x < player.anchor.width; x++) {
					if(flag) { break; }
					const roomX = (player.x + player.dx + x) - Math.floor(player.anchor.width * player.anchor.x);
					for(let y = 0; y < player.anchor.height; y++) {
						const roomY = (player.y + player.dy + y) - Math.floor(player.anchor.height * player.anchor.y);
						const playerOffset = (x + (y * player.anchor.width)) * 4;
						const roomOffset = (roomX + (roomY * roomMap.width)) * 4;
						// out of bounds on room
						if((roomOffset < 0) || (roomOffset > (roomMap.pixels.length - 4))) { continue; }
						// player map is transparent
						if(player.pixels[playerOffset + 3] == 0) { continue; }
						//console.log('poffs ' + playerOffset + ' xy ' + x + ', ' + y + 'alpha ' + player.pixels[playerOffset + 3] + 'r ' + player.pixels[playerOffset]);
						// room map is transparent
						if(roomMap.pixels[roomOffset + 3] == 0) { continue; }
						const r = roomMap.pixels[roomOffset];
						const g = roomMap.pixels[roomOffset + 1];
						const b = roomMap.pixels[roomOffset + 2];
						if((r == 0) && (g == 0) && (b == 0)) {
							//console.log('stop: xy ' + x + ', ' + y + ', playerxy = ' + player.x + ', ' + player.y + ', roomxy ' + roomX + ', ' + roomY);
							player.dx = 0;
							player.dy = 0;
							flag = true;
							break;
						}
						//if(x==0 && y==0) { console.log( "px,y: " + x + ", " + y + ", roomx,y: " + roomX + ", " + roomY); }
					}
				}
				//if(flag) { console.log('stop'); }
				player.x += player.dx;
				player.y += player.dy;
				if((player.dx != 0) || (player.dy != 0))console.log('px,y ' + player.x + ', ' + player.y);
				anim.x = player.x;
				anim.y = player.y;
				anim.zIndex = player.y;
				mapAnim.x = anim.x;
				mapAnim.y = anim.y;
				mapAnim.zIndex = anim.y + 1;
			});
		}
	);

/*
Pathfinding:
	Avatar
		Bound box
		Movement center
	Map
		2D grid with bounds
		Sprites with bounds
	Goal (x,y)
*/

</script>
</body>
</html>
