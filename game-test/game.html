<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Adventure Game Graphical Room Test</title>
	<script src="pixi.min.js"></script>
</head>
<body>
	<script src="game.js"></script>
	<script src="verbs.js"></script>
	<script type="text/javascript">
'use strict';
/*
	https://www.pixijs.com/
		2d library for adventure game
		http://www.yeahbutisitflash.com/?p=5226&cpage=1
		https://medium.com/dailyjs/how-to-build-a-simple-sprite-animation-in-javascript-b764644244aa

		https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-and-animations-with-pixijs5

	https://www.redblobgames.com/pathfinding/a-star/introduction.html
	https://briangrinstead.com/blog/astar-search-algorithm-in-javascript/

	https://www.pixijs.com/tutorials
	http://pixijs.download/release/docs/index.html
	https://stackoverflow.com/questions/667045/getpixel-from-html-canvas

	https://pixijs.io/examples/?v=v5.2.1#/masks/filter.js
		https://www.html5gamedevs.com/topic/43900-masking-an-image-with-multiple-blurred-circles/
	https://stackoverflow.com/questions/40722796/is-it-possible-to-create-a-pixi-texture-from-multiple-image-sources-in-pixi-js

https://www.aseprite.org/docs/cli/#platform-specific-details
https://community.aseprite.org/t/is-there-a-way-to-export-layers-into-the-same-spritesheet-on-top-of-eachother/230
`aseprite -b bg-test.aseprite --save-as map-{layer}.png`

Export a room:
`aseprite -b --split-layers --all-layers room0.aseprite --sheet room0.png --data room0.json`
aseprite -b --split-layers --all-layers --filename-format "{title} (tag:{tag},frame:{frame},{layer})" room0.aseprite --sheet room0.png --data room0.json

Export icons
aseprite -b --filename-format "{title} (tag:{tag},frame:{frame},{layer})" icons.aseprite --sheet icons.png --data icons.json

{title} (tag:{tag},{layer},frame:{frame})

https://ihatetomatoes.net/how-to-work-with-images-and-pixi-js/

*/

// http://scottmcdonnell.github.io/pixi-examples/index.html?s=demos&f=interactivity.js&title=Interactivity
function inputHandlers(player, screen) {
	function mvLeft() {
		console.log('left');
		player.dx = (player.dx < 0) ? 0 : -2;
		player.dy = 0;
	}
	function mvRight() {
		console.log('right');
		player.dx = (player.dx > 0) ? 0 : 2;
		player.dy = 0;
	}
	function mvUp() {
		console.log('up');
		player.dx = 0;
		player.dy = (player.dy < 0) ? 0 : -2;
	}
	function mvDown() {
		console.log('down');
		player.dx = 0;
		player.dy = (player.dy > 0) ? 0 : 2;
	}

	document.querySelector('body').addEventListener('keydown', function (evt) {
		// escape
		//if(evt.keyCode == 27) { eventHandler.mode(); }
		// left
		if(evt.keyCode == 37) { mvLeft(); }
		// up
		if(evt.keyCode == 38) { mvUp(); }
		// right
		if(evt.keyCode == 39) { mvRight(); }
		// down
		if(evt.keyCode == 40) { mvDown(); }
	});

/*
	function no_op() {}

	screen.interactive = true;
	screen
		// set the mousedown and touchstart callback...
		.on('mousedown', no_op)
		.on('touchstart', no_op)

		// set the mouseup and touchend callback...
		.on('mouseup', no_op)
		.on('touchend', no_op)
		.on('mouseupoutside', no_op)
		.on('touchendoutside', no_op)

		// set the mouseover callback...
		.on('mouseover', no_op)

		// set the mouseout callback...
		.on('mouseout', no_op)
		// you can also listen to click and tap events :
		.on('click', event => {
			console.log('click');
			console.log(event);
			const p = event.data.getLocalPosition(screen);
			console.log(p);
		})
		.on('pointertap', event => {
		});
*/
}

// The application will create a renderer using WebGL, if possible,
// with a fallback to a canvas render. It will also setup the ticker
// and the root stage PIXI.Container
const app = new PIXI.Application(); //{ resizeTo: window });

// The application will create a canvas element for you that you
// can then insert into the DOM
document.body.appendChild(app.view);



const ColorMessages = {
	'000000': function(p) {
		console.log('STOP');
		return p.stop(this);
	},
	'5fcde4': function(p) {
		return p.wade(this);
	},
	'5b6ee1': function(p) {
		return p.swim(this);
	},
	'76428a': function (p) {
		return p.fall(this);
	},
	'ff0001': function(p) {
		console.log('GO WEST');
		return p.goWest(this);
	},
	'ff0011': function(p) {
		return p.goNorth(this);
	},
	'ff0021': function(p) {
		console.log('GO EAST');
		return p.goEast(this);
	},
	'ff0031': function(p) {
		return p.goSouth(this);
	}
}

const GameObjects = {
}

function GameObject(name) {
	this.name = name;
	this.spritesheet = name;
	GameObjects[name] = this;
	this.nextState = '';
	this.currentState = '';
	this.states = {};
	this.colorToMessage = ColorMessages;
	this.x = 0;
	this.y = 0;
	this.dx = 0;
	this.dy = 0;
	this.carryable = true;
	this.displayName = name;
	this.displayState = '';

	this.getDescription = function() {
		return ('longDescription' in this) ? this.longDescription : '';
	}

	this.isCarryable = function(status) {
		if(arguments.length > 0) { this.carryable = status; }
		return this.carryable;
	}
	this.as = function (description) {
		this.longDescription = description;
		return this;
	};
	this.aka = function (name) {
		this.displayName = name;
		return this;
	};
	this.setXY = function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	};
	this.setState = function (state) {
		this.nextState = state;
		return this;
	};

	this.setLocation = function (room) {
		this.currentRoom = room;
	};

	this.calculateState = function() { return this.nextState; }

	this.removeDisplay = function(container) {
		if(this.currentState in this.states) { 
			const state = this.states[this.currentState];
			Object.keys(state.layers)
				.forEach(z => {
					container.removeChild(state.layers[z]);
				});
			// container.removeChild(oldState.map.sprite);
		}
	};

	this.display = function (container, refresh) {
		let newState = this.calculateState();
		if(refresh || (newState != this.currentState)) {
			this.displayed = true;
			const newStateObj = this.states[newState];
			this.removeDisplay(container);
			Object.keys(newStateObj.layers)
				.forEach(z => {
						console.log(z);
						console.log(newStateObj);
						newStateObj.layers[z].x = this.x;
						newStateObj.layers[z].y = this.y;
						newStateObj.layers[z].zIndex = parseInt(this.y) + parseInt(z);
						newStateObj.layers[z].play();
						container.addChild(newStateObj.layers[z]);
				});
			this.currentState = newState;
		}

		const state = this.states[this.currentState];
		Object.keys(state.layers)
			.forEach(z => {
				state.layers[z].x = this.x;
				state.layers[z].y = this.y;
				state.layers[z].zIndex = parseInt(this.y) + parseInt(z);
		});
/*
		state.map.sprite.alpha = 0.5;
		state.map.sprite.x = this.x;
		state.map.sprite.y = this.y;
		state.map.sprite.zIndex = this.y + 1;
		container.addChild(state.map.sprite);*/
	};
}

function Player(name) {
	GameObject.call(this, name);
	this.inventory = new InventoryRoom(name + '.inventory');

	this.isCarryable = function(status) { return false; }
	this.stop = function (sender) {
		console.log(this);
		this.dx = 0;
		this.dy = 0;
		return true;
	};
	this.wade = function (sender) {
		return false;
	};
	this.swim = function (sender) {
		return false;
	};
	this.goWest = function (sender) {
		console.log('west!');
		this.dx = 0;
		this.dy = 0;
		console.log(this.currentRoom.connections);
		if('west' in this.currentRoom.connections) {
			const newRoom = Rooms[this.currentRoom.connections.west];
			newRoom.moveTo(this, this.currentRoom, 'west', this.currentRoom.connections.west);
		}
		return true;
	};
	this.goNorth = function (sender) {
		console.log('north!');
		this.dx = 0;
		this.dy = 0;
		return true;
	};
	this.goEast =function (sender) {
		console.log('east!');
		this.dx = 0;
		this.dy = 0;
		console.log(this.currentRoom.connections);
		if('east' in this.currentRoom.connections) {
			const newRoom = Rooms[this.currentRoom.connections.east];
			newRoom.moveTo(this, this.currentRoom, 'east', this.currentRoom.connections.east);
		}
		return true;
	};
	this.goSouth = function (sender) {
		console.log('south!');
		this.dx = 0;
		this.dy = 0;
		return true;
	};

	this.fallState = false;
	this.fallCount = 0;
	this.fall = function (sender) {
		if(this.fallState) {
			this.fallState = true;
			this.fallCount = 0;
		} else if (this.fallcount > 44) {
			console.log('player fell too far.');
		} else {
			this.fallCount += 4;
		}
		this.dx = 0;
		this.dy = 4;
		return true;
	};

	this.calculateState = function() {
		if((this.dx == 0) && (this.dy == 0)) {
			return 'stand';
		} else {
			return 'walk';
		}
	};
}


const Rooms = {
};

function Room(name) {
	this.name = name;
	this.spritesheet = name;
	Rooms[name] = this;
	this.currentState = '';
	this.states = {};
	this.colorToMessage = ColorMessages;
	this.connections = {};
	this.contains = [];
	this.removeList = [];

	this.loadAssets = function() { return true; }

	this.setAnimation = function(container) {
		const state = this.states[this.currentState];
		console.log(this);
		Object.keys(state.layers)
			.forEach(z => {
				state.layers[z].play();
				container.addChild(state.layers[z]);
			});
		this.contains.forEach(obj => obj.display(container, true));
	};

	this.updateAnimations = function(container) {
		this.removeList.forEach(obj => obj.removeDisplay(container));
		this.contains.forEach(obj => obj.display(container, false));
	};

	this.removeObject = function(obj) {
		this.removeList.push(obj);
		const idx = this.contains.lastIndexOf(obj);
		if(idx >= 0) {
			this.contains.splice(idx, 1);
		}
	}

	/**
		@param obj Object to move.
		@param currentRoom The room (object) the object is in.
		@param travelling The string name of the "direction" the object is travelling in.
		@param roomName The string name of the destination room the object is being moved into.
	*/
	this.moveTo = function (obj, currentRoom, travelling, roomName) {
		console.log(currentRoom);
		currentRoom.removeObject(obj);
		const objMap = obj.states[obj.currentState].map;
		const roomMap = this.states[this.currentState].map;
		console.log(objMap);
		console.log(roomMap);
		const xCenter = Math.floor(objMap.width * objMap.x);
		const yCenter = Math.floor(objMap.height * objMap.y);
		switch (travelling) {
			case 'east':
				obj.x = (objMap.width - xCenter) + 2;
				obj.y = (roomMap.height  - 6) - (objMap.height - yCenter);
				break;
			case 'west':
				obj.x = (roomMap.width - 2) - (objMap.width - xCenter);
				obj.y = (roomMap.height  - 6) - (objMap.height - yCenter);
				break;
			case 'north':
				break;
			case 'south':
				break;
			default:
		}
		console.log(obj);
		console.log('new x y ' + obj.x + ', ' + obj.y);
		this.contains.push(obj);
		obj.setLocation(this);
	};

	this.as = function (description) {
		this.longDescription = description;
		return this;
	};

	this.getDescription = function() {
		return ('longDescription' in this) ? this.longDescription : '';
	}

	this.with = function (travel) {
		if('west' in travel) {
			this.connections.west = travel.west;
		} else if('east' in travel) {
			this.connections.east = travel.east;
		} else if('north' in travel) {
			this.connections.north = travel.north;
		} else if('south' in travel) {
			this.connections.south = travel.south;
		}
		return this;
	};

	this.having = function (gameObj) {
		gameObj.setLocation(this);
		this.contains.push(gameObj);
		return this;
	};
}

function ContainerRoom(name) {
	Room.call(this, name);

	this.priorRoom = [];

	this.moveTo = function (obj, currentRoom, travelling, roomName) {
		currentRoom.removeObject(obj);
		this.priorRoom.push({ obj: obj, x: obj.x, y: obj.y, room: currentRoom });

	}
}

function InventoryRoom(name) {
	Room.call(this, name);

	this.loadAssets = function() { return false; }
	this.moveTo = function (obj, currentRoom, travelling, roomName) {
		console.log(currentRoom);
		currentRoom.removeObject(obj);
		this.contains.push(obj);
		obj.setLocation(this);
		console.log(this.contains);
	}
}


const uiChrome = {
	icons: new PIXI.Container(),
	animations: {},
	attributes: {},
	verbs: {},
	verbList: [],
	width: 0,
	height: 0,
	addVerb: function (verb) {
		if(!(verb in this.verbs)) {
			this.verbList.push(verb);
			if(verb in Verbs) { this.verbs[verb] = Verbs[verb]; }
		}
	},
	display: function (screen) {
		let currentVerb = '';
		let currentGraphics = {};

		const that = this;
		screen.interactive = true;
		screen
			.on('click', event => {
				console.log('click');
				console.log(event);
				const p = event.data.getLocalPosition(screen);
				console.log(p);
				if (currentVerb != '') {
					const hitX = Math.floor(p.x);
					const hitY = Math.floor(p.y);
					if(!Verbs[currentVerb].target(hitX, hitY)) {
						currentVerb = '';
						that.icons.removeChild(currentGraphics);
					}
				}
			})
			.on('pointertap', event => {
			});

		this.icons.interactive = true;
		this.verbList.forEach(verb => {
			if(!Verbs[verb].available) { return; }
			const anim = this.animations[verb];
			anim.interactive = true;
			this.icons.addChild(anim);
			anim.play();
			anim.x = this.width + 1;
			this.width = anim.x + anim.width;
			this.height = Math.max(this.height, anim.height);
			console.log(verb + ', anim extents: ' + anim.width + ', ' + anim.height);
			anim.on('click', evt => {
				if(verb != currentVerb) {
					if(currentVerb != '') {
						this.icons.removeChild(currentGraphics);
						Verbs[currentVerb].deactivate();
					}
					if(Verbs[verb].activate()) {
						const graphics = new PIXI.Graphics();
						graphics.beginFill(0xfbf236, 0.5);
						graphics.lineStyle(1, 0xfbf236, 0.8);
						graphics.drawRect(0, 0, anim.width, anim.height);
						graphics.x = anim.x;
						this.icons.addChild(graphics);
						currentVerb = verb;
						currentGraphics = graphics;
					} else {
						currentVerb = '';
					}
				} else {
					if(currentVerb != '') {
						this.icons.removeChild(currentGraphics);
						currentVerb = '';
						Verbs[verb].deactivate();
					}
				}
				console.log(verb); 
			});
		});
	}
};

const GameState = new GameData();

/* Actual "game" description. */
const player = new Player('player').setXY(110, 316);
makeVerbs(player);

new Room('room0')
	.as('A large field with a boulder, tree, and pond.')
	.with({ east: 'room1' })
	.having((new GameObject('chest')).setXY(590, 185).setState('closed'))
	.having(player);
Rooms.room0.currentState = 'day';
new Room('room1')
	.as('The foothills of a mountain with a large sinkhole nearby.')
	.with({ west: 'room0' })
	.having((new GameObject('key')).setXY(77, 247));



/* Game start up code */
app.loader
	.add("player.json")
	.add("room0.json")
	.add("room1.json")
	.add("chest.json")
	.add("key.json")
	.add("icons.json")
	.load(
		(loader, resources) => {
			const screen = new PIXI.Container();
			const resizer = resize(app, screen);

			// Add event listener so that our resize function runs every time the
			// browser window is resized.
			window.addEventListener("resize", resizer);

			screen.sortableChildren = true;
			app.stage.addChild(uiChrome.icons);
			app.stage.addChild(screen);

			loadIconsFromSheet(uiChrome, 'icons', resources["icons.json"].spritesheet);
			uiChrome.display(screen);
			screen.y = uiChrome.height + 1;

			Object.keys(Rooms)
				.forEach(name => {
					if(!Rooms[name].loadAssets()) { return; }
					loadFromSheet(Rooms[name],
						Rooms[name].spritesheet,
						resources[Rooms[name].spritesheet + '.json'].spritesheet)
				});
			Object.keys(GameObjects)
				.forEach(name => {
					console.log(name);
					loadFromSheet(GameObjects[name],
						GameObjects[name].spritesheet,
						resources[GameObjects[name].spritesheet + '.json'].spritesheet)
					console.log(GameObjects[name]);
				});

			let currentRoom = player.currentRoom;
			currentRoom.setAnimation(screen);
			inputHandlers(player, screen);

			resizer();
			// Listen for frame updates
			app.ticker.add(() => {
				Object.keys(collide(player.states[player.currentState].map, player.x + player.dx, player.y + player.dy, currentRoom.colorToMessage,
						currentRoom.states[currentRoom.currentState].map))
					.forEach(rgb => currentRoom.colorToMessage[rgb](player));
				currentRoom.contains.forEach(obj => {
					if(obj == player) { return; }
					Object.keys(collide(player.states[player.currentState].map, player.x + player.dx - obj.x, player.y + player.dy - obj.y, 
							obj.colorToMessage, obj.states[obj.currentState].map))
						.forEach(rgb => obj.colorToMessage[rgb](player));
				});
				player.x += player.dx;
				player.y += player.dy;

				if(currentRoom != player.currentRoom) {
					screen.removeChildren();
					player.currentRoom.setAnimation(screen);
					resizer();
				}
				currentRoom = player.currentRoom;
				currentRoom.updateAnimations(screen);
			});
		}
	);



/*
Pathfinding:
	Avatar
		Bound box
		Movement center
	Map
		2D grid with bounds
		Sprites with bounds
	Goal (x,y)
*/

</script>
</body>
</html>
